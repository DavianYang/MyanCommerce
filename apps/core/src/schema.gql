# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AddressDto {
  city: String
  company: String
  country: CountryDto!
  createdAt: DateTime!
  defaultBillingAddress: Boolean
  defaultShippingAddress: Boolean
  fullName: String
  id: ID!
  phoneNumber: String
  postalCode: String
  province: String
  streetLine1: String!
  streetLine2: String
  updatedAt: DateTime!
}

type AdministratorDto {
  createdAt: DateTime!
  emailAddress: String!
  firstName: String!
  id: ID!
  lastName: String!
  updatedAt: DateTime!
  user: UserDto!
}

type AuthUserResponse {
  token: String!
  user: UserDto!
}

type AuthenticationDto {
  createdAt: DateTime!
  id: ID!
  identifier: String!
  identifierChangeToken: String
  method: String!
  passwordHash: String!
  passwordResetToken: String
  pendingIdentifier: String
  updatedAt: DateTime!
  user: UserDto!
  verificationToken: String
}

union AuthenticationResult = AuthUserResponse | EmailAddressConflictError | InvalidCredentialsError

type CountryDto {
  code: String!
  createdAt: DateTime!
  enabled: Boolean!
  id: ID!
  name: String!
  updatedAt: DateTime!
}

input CreateAddressInput {
  city: String
  company: String
  countryCode: String
  defaultBillingAddress: Boolean
  defaultShippingAddress: Boolean
  fullName: String
  phoneNumber: String
  postalCode: String
  province: String
  streetLine1: String!
  streetLine2: String
}

input CreateAdministratorInput {
  emailAddress: String!
  firstName: String!
  lastName: String!
  password: String!
  roleIds: [Int!]!
}

union CreateAdmnistratorResult = AdministratorDto | EmailAddressConflictError | PasswordValidationError

input CreateCountryInput {
  code: String!
  enabled: Boolean!
  name: String!
}

input CreateCustomerInput {
  emailAddress: String!
  firstName: String!
  lastName: String!
  password: String!
  phoneNumber: String
  title: String
}

union CreateCustomerResult = CustomerDto | EmailAddressConflictError | PasswordValidationError

input CreateRoleInput {
  code: String!
  description: String!
}

type CurrentUser {
  id: ID!
  identifier: String!
}

type CustomerDto {
  addresses: [AddressDto!]!
  createdAt: DateTime!
  deletedAt: DateTime
  emailAddress: String!
  firstName: String!
  id: ID!
  lastName: String!
  phoneNumber: String
  title: String
  updatedAt: DateTime!
  user: UserDto!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

type DeletionResponse {
  message: String
  result: DeletionResult!
}

enum DeletionResult {
  """The entity was successfully deleted"""
  DELETED

  """Deletion did not take place, reason given in message"""
  NOT_DELETED
}

"""
Returned when attempting to create a Customer with an email address already registered to an existing User.
"""
type EmailAddressConflictError {
  email: String!
  errorCode: String!
  message: String!
}

"""Returned if the user authentication credentials are not valid."""
type InvalidCredentialsError {
  authenticationError: String!
  errorCode: String!
  message: String!
}

union LoginAdminResult = CurrentUser | InvalidCredentialsError

input LoginInput {
  emailAddress: String!
  password: String!
}

union LoginShopResult = CurrentUser | InvalidCredentialsError

"""
Returned when attempting to register or verify a customer account without a password, when one is required.
"""
type MissingPasswordError {
  errorCode: String!
  message: String!
}

type Mutation {
  """
  Create a new Address and associate it with the Customer specified by customerId
  """
  createAddress(customerId: String!, input: CreateAddressInput!): AddressDto!
  createAdministrator(input: CreateAdministratorInput!): CreateAdmnistratorResult!
  createCountry(input: CreateCountryInput!): CountryDto!

  """
  Create a new Customer. If a password is provided, a new User will also be created an linked to the Customer.
  """
  createCustomer(input: CreateCustomerInput!): CreateCustomerResult!
  createRole(input: CreateRoleInput!): RoleDto!

  """Delete an existing Address with addressId"""
  deleteAddress(addressId: String!): Success!
  deleteCountry(id: String!): CountryDto!

  """Delete a Customer"""
  deleteCustomer(customerId: String!): DeletionResponse!
  deleteRole(id: Int!): RoleDto!
  loginAdmin(input: LoginInput!): LoginAdminResult!
  loginShop(input: LoginInput!): LoginShopResult!
  loginSocial: AuthenticationResult!
  registerCustomerAccount(input: RegisterCustomerInput!): RegisterCustomerResult!

  """Update an existing Address with addressId"""
  updateAddress(addressId: String!, input: UpdateAddressInput!): AddressDto!
  updateAdministrator: AdministratorDto!
  updateCountry(id: String!, input: UpdateCountryInput!): CountryDto!

  """Update an existing Customer"""
  updateCustomer(email: String!, input: UpdateCustomerInput!): UpdateCustomerResult!
  updateRole(id: Int!, input: UpdateRoleInput!): RoleDto!
  verifyCustomerAccount(input: VerifyCustomerInput!): VerifyCustomerResult!
}

"""
Returned when attempting to verify a customer account with a password, when a password has already been set.
"""
type PasswordAlreadySetError {
  errorCode: String!
  message: String!
}

"""
Returned when attempting to register or verify a customer account where the given password fails password validation.
"""
type PasswordValidationError {
  errorCode: String!
  message: String!
}

type Query {
  CurrentUser: UserDto!
  administrator(id: String!): AdministratorDto!
  administrators(cursor: String, skip: Int, take: Int): [AdministratorDto!]!
  countries(cursor: String, skip: Int, take: Int): [CountryDto!]!
  country(id: String!): CountryDto!
  customer(id: String!): CustomerDto!
  customers(cursor: String, skip: Int, take: Int): [CustomerDto!]!
  role(id: Int!): RoleDto!
  roles(cursor: String, skip: Int, take: Int): [RoleDto!]!
}

input RegisterCustomerInput {
  emailAddress: String!
  firstName: String!
  lastName: String!
  password: String
  phoneNumber: String
  title: String
}

union RegisterCustomerResult = EmailAddressConflictError | MissingPasswordError | PasswordValidationError | Success

type RoleDto {
  code: String!
  description: String!
  id: ID!
}

type Success {
  success: Boolean!
}

input UpdateAddressInput {
  city: String
  company: String
  countryCode: String
  defaultBillingAddress: Boolean
  defaultShippingAddress: Boolean
  fullName: String
  phoneNumber: String
  postalCode: String
  province: String
  streetLine1: String
  streetLine2: String
}

input UpdateCountryInput {
  code: String
  enabled: Boolean
  name: String
}

input UpdateCustomerInput {
  emailAddress: String
  firstName: String
  lastName: String
  password: String
  phoneNumber: String
  title: String
}

union UpdateCustomerResult = CustomerDto | EmailAddressConflictError

input UpdateRoleInput {
  code: String!
  description: String!
}

type UserDto {
  authentication: [AuthenticationDto!]!
  createdAt: DateTime!
  deletedAt: DateTime
  id: ID!
  identifier: String!
  lastLogin: DateTime
  roles: [RoleDto!]!
  updatedAt: DateTime!
  verified: Boolean!
}

"""
Returned if the verification token (used to verify a Customer's email address) is valid, but has expired according to the verificationTokenDuration setting in the AuthOptions.
"""
type VerificationTokenExpired {
  errorCode: String!
  message: String!
}

"""
Returned if the verification token (used to verify a Customer's email address) is either invalid or does not match any expected tokens.
"""
type VerificationTokenInvalidError {
  errorCode: String!
  message: String!
}

input VerifyCustomerInput {
  password: String
  token: String!
}

union VerifyCustomerResult = CurrentUser | MissingPasswordError | PasswordAlreadySetError | PasswordValidationError | VerificationTokenExpired | VerificationTokenInvalidError
